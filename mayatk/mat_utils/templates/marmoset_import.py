# Marmoset Toolbag import & material-setup script.
# Generated by mayatk.mat_utils.MarmosetExporter — do not edit by hand.
import json
import os

try:
    import mset
except ImportError:
    mset = None

FBX_FILE = r"__FBX_PATH__"
MANIFEST_FILE = r"__MANIFEST_PATH__"
SAVE_PATH = r"__SAVE_PATH__"
try:
    SHOULD_QUIT = __SHOULD_QUIT__
except NameError:
    SHOULD_QUIT = False


# -- Slot → Toolbag field mapping ------------------------------------------
# Each entry is (tb_module_attr, field_name).
# tb_module_attr is the attribute on the Toolbag material object that holds
# the sub-module (e.g. ``mat.getSubroutine("surface")``), and field_name is
# the texture-map field within that sub-module.
SLOT_MAP = {
    "baseColor": ("albedo", "Albedo Map"),
    "normal": ("surface", "Normal Map"),
    "roughness": ("microsurface", "Microsurface Map"),
    "metallic": ("reflectivity", "Metalness Map"),
    "ambientOcclusion": ("occlusion", "Occlusion Map"),
    "emission": ("emissive", "Emissive Map"),
    "opacity": ("transparency", "Transparency Map"),
}


def _find_material(name, scene_mats):
    """Return the Toolbag material whose name matches *name*.

    FBX importers sometimes append suffixes (``_ncl1_1``, ``(Instance)``,
    etc.), so we try an exact match first, then fall back to substring.
    """
    # Exact
    for m in scene_mats:
        if m.name == name:
            return m
    # Substring / prefix
    for m in scene_mats:
        if m.name.startswith(name) or name in m.name:
            return m
    return None


def main():
    print(f"[Maya→Toolbag] FBX:      {FBX_FILE}")
    print(f"[Maya→Toolbag] Manifest: {MANIFEST_FILE}")

    if not os.path.isfile(FBX_FILE):
        print("ERROR: FBX file not found.")
        return
    if not os.path.isfile(MANIFEST_FILE):
        print("ERROR: Manifest file not found.")
        return

    # 1. Import model
    mset.importModel(FBX_FILE)

    # 2. Read manifest
    with open(MANIFEST_FILE, "r", encoding="utf-8") as fh:
        data = json.load(fh)
    mat_map = data.get("materials", {})

    if not mat_map:
        print("Manifest contains no materials — nothing to wire.")
        return

    # 3. Collect Toolbag materials
    scene_mats = [o for o in mset.getAllObjects() if isinstance(o, mset.MaterialObject)]
    print(f"Scene contains {len(scene_mats)} material(s).")

    # 4. Wire textures
    wired = 0
    for mat_name, slots in mat_map.items():
        tb_mat = _find_material(mat_name, scene_mats)
        if tb_mat is None:
            print(f"  SKIP  '{mat_name}' — no matching Toolbag material.")
            continue

        print(f"  Wiring '{mat_name}' → '{tb_mat.name}'")
        for slot_key, tex_path in slots.items():
            mapping = SLOT_MAP.get(slot_key)
            if not mapping:
                print(f"    ? No Toolbag mapping for slot '{slot_key}', skipping.")
                continue

            module_attr, field_name = mapping
            try:
                sub = getattr(tb_mat, module_attr, None)
                if sub is None:
                    print(f"    ? Material has no '{module_attr}' module.")
                    continue
                sub.getField(field_name).set(tex_path)
                wired += 1
                print(f"    ✓ {slot_key} → {os.path.basename(tex_path)}")
            except Exception as exc:
                print(f"    ✗ {slot_key}: {exc}")

    print(f"[Maya→Toolbag] Done — wired {wired} texture slot(s).")

    # 5. Save & Quit (Automation)
    if SAVE_PATH and not SAVE_PATH.startswith("__"):
        print(f"Saving scene: {SAVE_PATH}")
        mset.saveScene(SAVE_PATH)

    if SHOULD_QUIT:
        print("Quitting Toolbag...")
        mset.quit()


if __name__ == "__main__":
    main()
